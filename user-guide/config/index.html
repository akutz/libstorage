<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://github.com/codedellemc/libstorage/user-guide/config/">
        <link rel="shortcut icon" href="favicon.ico">
        

	<title>Configuration - libStorage</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="../../css/emccode.css" rel="stylesheet">
        <link href="../../css/emccode-font.css" rel="stylesheet">
        <link href="../../css/hX.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        

        <!-- scroll fix -->
        <script>
            //var shiftWindow = function() { scrollBy(0, -40) };
            //if (location.hash) shiftWindow();
            //window.addEventListener("hashchange", shiftWindow);
        </script>

    </head>

    <body >

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">
                <i class="fa icon-libstorage-logo"></i>
                libStorage
            </a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">User Guide <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li class="active">
                            <a href="./">Configuration</a>
                        </li>
                    
                        <li >
                            <a href="../storage-providers/">Storage Providers</a>
                        </li>
                    
                        <li >
                            <a href="../schedulers/">Schedulers</a>
                        </li>
                    
                    </ul>
                </li>
                <!--
                smart menus
                <li><a href="#">User Guide <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                    
                    
                        <li class="active">
                            <a href="./">Configuration</a>
                        </li>
                    
                    
                    
                        <li >
                            <a href="../storage-providers/">Storage Providers</a>
                        </li>
                    
                    
                    
                        <li >
                            <a href="../schedulers/">Schedulers</a>
                        </li>
                    
                    
                    </ul>
                </li>
                -->
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Developers Guide <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../dev-guide/project-guidelines/">Project Guidelines</a>
                        </li>
                    
                        <li >
                            <a href="../../dev-guide/build-reference/">Build Reference</a>
                        </li>
                    
                        <li >
                            <a href="../../dev-guide/release-process/">Release Process</a>
                        </li>
                    
                    </ul>
                </li>
                <!--
                smart menus
                <li><a href="#">Developers Guide <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                    
                    
                        <li >
                            <a href="../../dev-guide/project-guidelines/">Project Guidelines</a>
                        </li>
                    
                    
                    
                        <li >
                            <a href="../../dev-guide/build-reference/">Build Reference</a>
                        </li>
                    
                    
                    
                        <li >
                            <a href="../../dev-guide/release-process/">Release Process</a>
                        </li>
                    
                    
                    </ul>
                </li>
                -->
            
            
            
                <li >
                    <a href="../../api/">API</a>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../about/contributing/">Contributing</a>
                        </li>
                    
                        <li >
                            <a href="../../about/license/">License</a>
                        </li>
                    
                        <li >
                            <a href="../../about/release-notes/">Release Notes</a>
                        </li>
                    
                    </ul>
                </li>
                <!--
                smart menus
                <li><a href="#">About <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                    
                    
                        <li >
                            <a href="../../about/contributing/">Contributing</a>
                        </li>
                    
                    
                    
                        <li >
                            <a href="../../about/license/">License</a>
                        </li>
                    
                    
                    
                        <li >
                            <a href="../../about/release-notes/">Release Notes</a>
                        </li>
                    
                    
                    </ul>
                </li>
                -->
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li >
                    <a rel="next" href="../..">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../storage-providers/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/codedellemc/libstorage.git">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
                <li>
                    <a href="https://emccode.github.io">
                        <i class="fa icon-emccode-logo"></i>
                    </a>
                </li>
            </ul>
        </div>
    </div>
</div>
        
        <div class="container ">
            <div class="col-md-3"><div id="sidenav" class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#configuring-libstorage">Configuring libStorage</a></li>
        
            <li><a href="#overview">Overview</a>
            
                <ul class="nav nav-stacked">
                
                <li><a href="#clientserver-configuration">Client/Server Configuration</a><!--
                -->
                </li>
                
                </ul>
            
            </li>
        
            <li><a href="#basic-configuration">Basic Configuration</a>
            
                <ul class="nav nav-stacked">
                
                <li><a href="#simple">Simple</a><!--
                -->
                </li>
                
                <li><a href="#tcp">TCP</a><!--
                -->
                </li>
                
                <li><a href="#tcptls">TCP+TLS</a><!--
                -->
                </li>
                
                <li><a href="#unix-socket">UNIX Socket</a><!--
                -->
                </li>
                
                <li><a href="#multiple-endpoints">Multiple Endpoints</a><!--
                -->
                </li>
                
                <li><a href="#multiple-services">Multiple Services</a><!--
                -->
                </li>
                
                <li><a href="#logging">Logging</a><!--
                -->
                </li>
                
                </ul>
            
            </li>
        
            <li><a href="#advanced-configuration">Advanced Configuration</a>
            
                <ul class="nav nav-stacked">
                
                <li><a href="#tls-configuration">TLS Configuration</a><!--
                
                <ul class="nav nav-stacked">
                    
                    <li><a href="#insecure-tls">Insecure TLS</a></li>
                    
                    <li><a href="#server-cert-fingerprint">Server Cert Fingerprint</a></li>
                    
                    <li><a href="#trusted-certs-file">Trusted Certs File</a></li>
                    
                    <li><a href="#require-client-side-certs">Require Client-Side Certs</a></li>
                    
                </ul>
                -->
                </li>
                
                <li><a href="#authentication">Authentication</a><!--
                
                <ul class="nav nav-stacked">
                    
                    <li><a href="#global-configuration">Global Configuration</a></li>
                    
                    <li><a href="#service-configuration">Service Configuration</a></li>
                    
                    <li><a href="#global-vs-service">Global vs. Service</a></li>
                    
                    <li><a href="#client-config">Client Config</a></li>
                    
                </ul>
                -->
                </li>
                
                <li><a href="#embedded-configuration">Embedded Configuration</a><!--
                -->
                </li>
                
                <li><a href="#data-directories">Data Directories</a><!--
                -->
                </li>
                
                <li><a href="#configuration-methods">Configuration Methods</a><!--
                -->
                </li>
                
                <li><a href="#configuration-files">Configuration Files</a><!--
                -->
                </li>
                
                <li><a href="#configuration-properties">Configuration Properties</a><!--
                -->
                </li>
                
                <li><a href="#inherited-properties">Inherited Properties</a><!--
                
                <ul class="nav nav-stacked">
                    
                    <li><a href="#overriding-inherited-properties">Overriding Inherited Properties</a></li>
                    
                </ul>
                -->
                </li>
                
                <li><a href="#logging-configuration">Logging Configuration</a><!--
                -->
                </li>
                
                <li><a href="#tasks-configuration">Tasks Configuration</a><!--
                -->
                </li>
                
                <li><a href="#driver-configuration">Driver Configuration</a><!--
                
                <ul class="nav nav-stacked">
                    
                    <li><a href="#os-drivers">OS Drivers</a></li>
                    
                    <li><a href="#storage-drivers">Storage Drivers</a></li>
                    
                    <li><a href="#integration-drivers">Integration Drivers</a></li>
                    
                </ul>
                -->
                </li>
                
                <li><a href="#volume-configuration">Volume Configuration</a><!--
                
                <ul class="nav nav-stacked">
                    
                    <li><a href="#volume-properties">Volume Properties</a></li>
                    
                    <li><a href="#disable-create">Disable Create</a></li>
                    
                    <li><a href="#disable-remove">Disable Remove</a></li>
                    
                    <li><a href="#preemption">Preemption</a></li>
                    
                    <li><a href="#ignore-used-count">Ignore Used Count</a></li>
                    
                    <li><a href="#volume-path-cache">Volume Path Cache</a></li>
                    
                    <li><a href="#volume-root-path">Volume Root Path</a></li>
                    
                </ul>
                -->
                </li>
                
                <li><a href="#rest-configuration">REST Configuration</a><!--
                
                <ul class="nav nav-stacked">
                    
                    <li><a href="#parse-post-options">Parse POST Options</a></li>
                    
                </ul>
                -->
                </li>
                
                </ul>
            
            </li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="configuring-libstorage">Configuring libStorage<a class="headerlink" href="#configuring-libstorage" title="Permanent link">&para;</a></h1>
<p>Tweak this, turn that, peek behind the curtain...</p>
<hr />
<h2 id="overview">Overview<a class="headerlink" href="#overview" title="Permanent link">&para;</a></h2>
<p>This page reviews how to configure <code>libStorage</code> to suit any environment,
beginning with the the most common use cases, exploring recommended guidelines,
and finally, delving into the details of more advanced settings.</p>
<h3 id="clientserver-configuration">Client/Server Configuration<a class="headerlink" href="#clientserver-configuration" title="Permanent link">&para;</a></h3>
<p>Except when specified otherwise, the configuration examples below assume the
<code>libStorage</code> client and server exist on the same host. However, that is not at
all a requirement. It is fully possible, and in fact the entire purpose of
<code>libStorage</code>, that the client and server be able to function on different
systems. One <code>libStorage</code> server should be able to support hundreds of clients.
Yet for the sake of completeness, the examples below show both configurations
merged.</p>
<p>When configuring a <code>libStorage</code> client and server for different systems, there
will be a few differences from the examples below:</p>
<ul>
<li>
<p>The examples show <code>libStorage</code> configured with its server component hosted
    on a UNIX socket. This is ideal for when the client/server exist on the same
    host as it reduces security risks. However, in most real-world scenarios
    the client and server are <em>not</em> residing on the same host, the
    <code>libStorage</code>  server should use a TCP endpoint so it can be accessed
    remotely.</p>
</li>
<li>
<p>In a distributed configuration the actual driver configuration sections
    need only occur on the server-side. The entire purpose of <code>libStorage</code>'s
    distributed nature is to enable clients without any knowledge of how to
    access a storage platform the ability to connect to a remote server that
    maintains that storage platform access information.</p>
</li>
</ul>
<h2 id="basic-configuration">Basic Configuration<a class="headerlink" href="#basic-configuration" title="Permanent link">&para;</a></h2>
<p>This section outlines the most common configuration scenarios encountered by
<code>libStorage</code>'s users.</p>
<h3 id="simple">Simple<a class="headerlink" href="#simple" title="Permanent link">&para;</a></h3>
<p>The first example is a simple <code>libStorage</code> configuration with the VirtualBox
storage driver. The below example omits the host property, but the configuration
is still valid. If the <code>libstorage.host</code> property is not found, the server is
hosted via a temporary UNIX socket file in <code>/var/run/libstorage</code>.</p>
<div class="admonition note">
<p class="admonition-title">note</p>
<p>Please remember to replace the placeholders in the following examples
with values valid for the systems on which the examples are executed.</p>
<p>The example below specifies the <code>volumePath</code> property as
<code>$HOME/VirtualBox/Volumes</code>. While the text <code>$HOME</code> will be replaced with
the actual value for that environment variable at runtime, the path may
still be invalid. The <code>volumePath</code> property should reflect a path on the
system on which the VirtualBox server is running, and that is not always
the same system on which the <code>libStorage</code> server is running.</p>
<p>So please, make sure to update the <code>volumePath</code> property for the VirtualBox
driver to a path valid on the system on which the VirtualBox server is
running.</p>
<p>The same goes for VirtualBox property <code>endpoint</code> as the VirtualBox
web service is not always available at <code>10.0.2.2:18083</code>.</p>
</div>
<pre><code class="yaml">libstorage:
  server:
    services:
      virtualbox:
        driver: virtualbox
        virtualbox:
          endpoint:       http://10.0.2.2:18083
          tls:            false
          volumePath:     $HOME/VirtualBox/Volumes
          controllerName: SATA
</code></pre>

<h3 id="tcp">TCP<a class="headerlink" href="#tcp" title="Permanent link">&para;</a></h3>
<p>The following example illustrates how to configure a <code>libStorage</code> client and
server running on the same host. The server has one endpoint on which it is
accessible - a single TCP port, 7979, bound to the localhost network interface.</p>
<pre><code class="yaml">libstorage:
  host: tcp://127.0.0.1:7979
  server:
    services:
      virtualbox:
        driver: virtualbox
        virtualbox:
          endpoint:       http://10.0.2.2:18083
          tls:            false
          volumePath:     $HOME/VirtualBox/Volumes
          controllerName: SATA
</code></pre>

<h3 id="tcptls">TCP+TLS<a class="headerlink" href="#tcptls" title="Permanent link">&para;</a></h3>
<p>The following example illustrates how to configure a <code>libStorage</code> client and
server running on the same host. The server has one endpoint on which it is
accessible - a single TCP port, 7979, bound to all of the host's network
interfaces. This means that the server is accessible via external clients, not
just those running on the same host.</p>
<p>Because of the public nature of this <code>libStorage</code> server, it is a good idea to
encrypt communications between client and server.</p>
<pre><code class="yaml">libstorage:
  host: tcp://127.0.0.1:7979
  client:
    tls: true
  server:
    tls:
      certFile: /etc/libstorage/libstorage-server.crt
      keyFile: /etc/libstorage/libstorage-server.key
    services:
      virtualbox:
        driver: virtualbox
        virtualbox:
          endpoint:       http://10.0.2.2:18083
          tls:            false
          volumePath:     $HOME/VirtualBox/Volumes
          controllerName: SATA
</code></pre>

<div class="admonition note">
<p class="admonition-title">note</p>
<p>Please note that in the above example the property <code>libstorage.client</code> has
been introduced. This property is always present, even if not explicitly
specified. It exists to override <code>libStorage</code> properties for the client
only, such as TLS settings, logging, etc.</p>
</div>
<h3 id="unix-socket">UNIX Socket<a class="headerlink" href="#unix-socket" title="Permanent link">&para;</a></h3>
<p>For the security conscious, there is no safer way to run a client/server setup
on a single system than the option to use a UNIX socket. The socket offloads
authentication and relies on the file system file access to ensure authorized
users can use the <code>libStorage</code> API.</p>
<pre><code class="yaml">libstorage:
  host: unix:///var/run/libstorage/localhost.sock
  server:
    services:
      virtualbox:
        driver: virtualbox
        virtualbox:
          endpoint:       http://10.0.2.2:18083
          tls:            false
          volumePath:     $HOME/VirtualBox/Volumes
          controllerName: SATA
</code></pre>

<p>It is possible to apply TLS to the UNIX socket. Refer to the TCP+TLS section
for applying TLS to the UNIX sockets.</p>
<h3 id="multiple-endpoints">Multiple Endpoints<a class="headerlink" href="#multiple-endpoints" title="Permanent link">&para;</a></h3>
<p>There may be occasions when it is desirable to provide multiple ingress vectors
for the <code>libStorage</code> API. In these situations, configuring multiple endpoints
is the solution. The below example illustrates how to configure three endpoints:</p>
<table>
<thead>
<tr>
<th>endpoint</th>
<th>protocol</th>
<th>address</th>
<th>tls</th>
<th>localhost only</th>
</tr>
</thead>
<tbody>
<tr>
<td>sock</td>
<td>unix socket</td>
<td>/var/run/libstorage/localhost.sock</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>private</td>
<td>tcp</td>
<td>127.0.0.1:7979</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>public</td>
<td>tcp</td>
<td>*:7980</td>
<td>yes</td>
<td>no</td>
</tr>
</tbody>
</table>
<pre><code class="yaml">libstorage:
  host: unix:///var/run/libstorage/localhost.sock
  server:
    services:
      virtualbox:
        driver: virtualbox
        virtualbox:
          endpoint:       http://10.0.2.2:18083
          tls:            false
          volumePath:     $HOME/VirtualBox/Volumes
          controllerName: SATA
    endpoints:
      sock:
        address: unix:///var/run/libstorage/localhost.sock
      private:
        address: tcp://127.0.0.1:7979
      public:
        address: tcp://:7980
        tls:
          certFile: /etc/libstorage/libstorage-server.crt
          keyFile: /etc/libstorage/libstorage-server.key
          trustedCertsFile: /etc/libstorage/trusted-certs.crt
          clientCertRequired: true
</code></pre>

<p>With all three endpoints defined explicitly in the above example, why leave the
property <code>libstorage.host</code> in the configuration at all? When there are no
endpoints defined, the <code>libStorage</code> server will attempt to create a default
endpoint using the value from the property <code>libstorage.host</code>. However, even
when there's at least one explicitly defined endpoint, the <code>libstorage.host</code>
property still serves a very important function -- it is the property used
by the <code>libStorage</code> client to determine which to which endpoint to connect.</p>
<h3 id="multiple-services">Multiple Services<a class="headerlink" href="#multiple-services" title="Permanent link">&para;</a></h3>
<p>All of the previous examples have used the VirtualBox storage driver as the
sole measure of how to configure a <code>libStorage</code> service. However, it is possible
to configure many services at the same time in order to provide access to
multiple storage drivers of different types, or even different configurations
of the same driver.</p>
<p>The following example demonstrates how to configure three <code>libStorage</code> services:</p>
<table>
<thead>
<tr>
<th>service</th>
<th>driver</th>
</tr>
</thead>
<tbody>
<tr>
<td>virtualbox-00</td>
<td>virtualbox</td>
</tr>
<tr>
<td>virtualbox-01</td>
<td>virtualbox</td>
</tr>
<tr>
<td>scaleio</td>
<td>scaleio</td>
</tr>
</tbody>
</table>
<p>Notice how the <code>virtualbox-01</code> service includes an added <code>integration</code> section.
The integration definition refers to the integration interface and parameters
specific to incoming requests through this layer. In this case we defined
<code>libstorage.server.services.virtualbox-01</code> with the
<code>integration.volume.operations.create.default.size</code> parameter set. This enables all
create requests that come in through <code>virtualbox-01</code> to have a default size of
1GB. So although it is technically the same platform below the covers,
<code>virtualbox-00</code> requests may have different default values than those defined
in <code>virtualbox-01</code>.</p>
<pre><code class="yaml">libstorage:
  server:
    services:
      virtualbox-00:
        driver: virtualbox
        virtualbox:
          endpoint:       http://10.0.2.2:18083
          tls:            false
          volumePath:     $HOME/VirtualBox/Volumes-00
          controllerName: SATA
      virtualbox-01:
        driver: virtualbox
        virtualbox:
          endpoint:       http://10.0.2.2:18083
          tls:            false
          volumePath:     $HOME/VirtualBox/Volumes-01
          controllerName: SATA
        integration:
          volume:
            operations:
              create:
                default:
                  size: 1 # GB
      scaleio:
        driver: scaleio
        scaleio:
          endpoint: https://gateway_ip/api
          insecure: true
          userName: username
          password: password
          systemName: tenantName
          protectionDomainName: protectionDomainName
          storagePoolName: storagePoolName
</code></pre>

<p>A very important point to make about the relationship between services and
endpoints is that all configured services are available on all endpoints. In
the future this may change, and <code>libStorage</code> may support endpoint-specific
service definitions, but for now if a service is configured, it is accessible
via any of the available endpoint addresses.</p>
<p>Between the three services above, clearly one major difference is that two
services host one driver, VirtualBox, and the third service hosts ScaleIO.
However, why two services for one driver, in this case, VirtualBox? Because,
in addition to services being configured to host different types of drivers,
services can also host different driver configurations. In service
<code>virtualbox-00</code>, the volume path is <code>$HOME/VirtualBox/Volumes-00</code>,
whereas for service <code>virtualbox-01</code>, the volume path is
<code>$HOME/VirtualBox/Volumes-01</code>.</p>
<h3 id="logging">Logging<a class="headerlink" href="#logging" title="Permanent link">&para;</a></h3>
<p>Sometimes it helps to see a little more, or maybe even a little less,
information in the logs. Configuring logging is quite straight-forward:</p>
<pre><code class="yaml">libstorage:
  logging:
    level: warn
  server:
    logging:
      level: info
    services:
      virtualbox:
        driver: virtualbox
        virtualbox:
          endpoint:       http://10.0.2.2:18083
          tls:            false
          volumePath:     $HOME/VirtualBox/Volumes
          controllerName: SATA
</code></pre>

<p>The <code>libStorage</code> configuration shown above uses a global log level of <code>warn</code>,
and a more verbose, <code>info</code> log level for just the server.</p>
<h2 id="advanced-configuration">Advanced Configuration<a class="headerlink" href="#advanced-configuration" title="Permanent link">&para;</a></h2>
<p>The following sections detail every last aspect of how <code>libStorage</code> works and can
be configured.</p>
<h3 id="tls-configuration">TLS Configuration<a class="headerlink" href="#tls-configuration" title="Permanent link">&para;</a></h3>
<p>This section reviews the several supported TLS configuration options.</p>
<h4 id="insecure-tls">Insecure TLS<a class="headerlink" href="#insecure-tls" title="Permanent link">&para;</a></h4>
<p>The following example illustrates how to configure the libStorage client to
skip validation of a provided server-side certificate:</p>
<pre><code class="yaml">libstorage:
  host: tcp://127.0.0.1:7979
  client:
    tls: insecure
  server:
    tls:
      certFile: /etc/libstorage/libstorage-server.crt
      keyFile: /etc/libstorage/libstorage-server.key
    services:
      virtualbox:
        driver: virtualbox
        virtualbox:
          endpoint:       http://10.0.2.2:18083
          tls:            false
          volumePath:     $HOME/VirtualBox/Volumes
          controllerName: SATA
</code></pre>

<div class="admonition note">
<p class="admonition-title">note</p>
<p>The above example instructs the client-side TLS configuration to operate in
<em>insecure</em> mode. This means the client is not attempting to verify the
certificate provided by the server. This is a security risk and should not
ever be used in production.</p>
</div>
<h4 id="server-cert-fingerprint">Server Cert Fingerprint<a class="headerlink" href="#server-cert-fingerprint" title="Permanent link">&para;</a></h4>
<p>While TLS should never be configured as insecure in production, a compromise
between no TLS and insecure TLS is specifying a server certificate's SHA256
fingerprint.</p>
<p>For example, the following command can be used to print google.com's SHA256
fingerprint:</p>
<pre><code class="bash">$ openssl s_client -connect google.com:443  &lt;/dev/null | \
  sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' | \
  openssl x509 -noout -fingerprint -sha256
</code></pre>

<p>The above command will produce output similar to the following:</p>
<pre><code class="bash">depth=2 /C=US/O=GeoTrust Inc./CN=GeoTrust Global CA
verify error:num=20:unable to get local issuer certificate
verify return:0
DONE
SHA256 Fingerprint=15:92:77:BE:6C:90:D3:FB:59:29:9C:51:A7:DB:5C:16:55:BD:B9:9E:E7:7E:C1:9B:30:C3:74:99:21:5F:08:99
</code></pre>

<p>Using the above output, it's possible to configure a libStorage client to
communicate to a remote, libStorage API endpoint using TLS if, and only if,
the fingerprint of remote endpoint's certificate matches the one the client
expects. The following configuration achieves just that:</p>
<pre><code class="yaml">libstorage:
  host: tcp://127.0.0.1:7979
  client:
    tls: &quot;sha256:15:92:77:BE:6C:90:D3:FB:59:29:9C:51:A7:DB:5C:16:55:BD:B9:9E:E7:7E:C1:9B:30:C3:74:99:21:5F:08:99&quot;
  server:
    tls:
      certFile: /etc/libstorage/libstorage-server.crt
      keyFile: /etc/libstorage/libstorage-server.key
    services:
      virtualbox:
        driver: virtualbox
        virtualbox:
          endpoint:       http://10.0.2.2:18083
          tls:            false
          volumePath:     $HOME/VirtualBox/Volumes
          controllerName: SATA
</code></pre>

<p>With <code>DEBUG</code> level logging enabled, the libStorage client logs reflect the
matched fingerprint:</p>
<pre><code class="bash">DEBU[0000] comparing tls fingerprints                    actualFingerprint=159277be6c90d3fb59299c51a7db5c1655bdb99ee77ec19b30c37499215f0899 expectedFingerprint=159277be6c90d3fb59299c51a7db5c1655bdb99ee77ec19b30c37499215f0899 service=virtualbox storageDriver=libstorage time=1488821773182
DEBU[0000] matched tls fingerprints                      actualFingerprint=159277be6c90d3fb59299c51a7db5c1655bdb99ee77ec19b30c37499215f0899 expectedFingerprint=159277be6c90d3fb59299c51a7db5c1655bdb99ee77ec19b30c37499215f0899 service=virtualbox storageDriver=libstorage time=1488821773182
</code></pre>

<h4 id="trusted-certs-file">Trusted Certs File<a class="headerlink" href="#trusted-certs-file" title="Permanent link">&para;</a></h4>
<p>This TLS configuration example describes how to instruct the libStorage client
to validate the provided server-side certificate using a custom trusted CA file.
This avoids the perils of insecure TLS while still enabling a privately signed
or snake-oil server-side certificate.</p>
<pre><code class="yaml">libstorage:
  host: tcp://127.0.0.1:7979
  client:
    tls:
      trustedCertsFile: $HOME/.libstorage/trusted-certs.crt
  server:
    tls:
      certFile: /etc/libstorage/libstorage-server.crt
      keyFile: /etc/libstorage/libstorage-server.key
    services:
      virtualbox:
        driver: virtualbox
        virtualbox:
          endpoint:       http://10.0.2.2:18083
          tls:            false
          volumePath:     $HOME/VirtualBox/Volumes
          controllerName: SATA
</code></pre>

<h4 id="require-client-side-certs">Require Client-Side Certs<a class="headerlink" href="#require-client-side-certs" title="Permanent link">&para;</a></h4>
<p>The final TLS example explains how to configure the libStorage server to
to require certificates from clients. This configuration enables the use of
client-side certificates as a means of authorization.</p>
<pre><code class="yaml">libstorage:
  host: tcp://127.0.0.1:7979
  client:
    tls:
      certFile: $HOME/.libstorage/libstorage-client.crt
      keyFile: $HOME/.libstorage/libstorage-client.key
      trustedCertsFile: $HOME/.libstorage/trusted-certs.crt
  server:
    tls:
      certFile: /etc/libstorage/libstorage-server.crt
      keyFile: /etc/libstorage/libstorage-server.key
      trustedCertsFile: /etc/libstorage/trusted-certs.crt
      clientCertRequired: true
    services:
      virtualbox:
        driver: virtualbox
        virtualbox:
          endpoint:       http://10.0.2.2:18083
          tls:            false
          volumePath:     $HOME/VirtualBox/Volumes
          controllerName: SATA
</code></pre>

<p>A typical scenario that employs the above example would also involve the
server certificate to have a dual purpose as an intermediate signing authority
that has signed the allowed client certificates. Or at the very least the
server certificate would be signed by the same intermediate CA that is used
to sign the client-side certs.</p>
<h3 id="authentication">Authentication<a class="headerlink" href="#authentication" title="Permanent link">&para;</a></h3>
<p>In addition to TLS, the libStorage API includes support for
<a href="https://jwt.io">JSON Web Tokens</a> (JWT) in order to provide authentication
and authorization.</p>
<p>A JWT is transmitted along with an API call in the standard HTTP <code>Authorization</code>
header as an OAuth 2.0 <a href="https://tools.ietf.org/html/rfc6750">Bearer</a> token. For
example:</p>
<pre><code>GET /volumes

Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MjI2ODg1NTAsImlhdCI6MTQ5MTIzODk1MCwibmJmIjoxNDkxMjM4OTUwLCJzdWIiOiJha3V0eiJ9.3eAA7AQZUGrwA42H64qKbu8QF_AHpSsJSMR0FALnKj8
</code></pre>

<p>The above token is split into three discreet parts:</p>
<p><code>HEADER</code>.<code>PAYLOAD</code>.<code>SIGNATURE</code></p>
<p>The decoded header is:</p>
<pre><code class="json">{
  &quot;alg&quot;: &quot;HS256&quot;,
  &quot;typ&quot;: &quot;JWT&quot;
}
</code></pre>

<p>The decoded payload is:</p>
<pre><code class="json">{
  &quot;exp&quot;: 1522688550,
  &quot;iat&quot;: 1491238950,
  &quot;nbf&quot;: 1491238950,
  &quot;sub&quot;: &quot;akutz&quot;
}
</code></pre>

<p>The signature is the result of signing the concatenation of the header and
signature after Base64 encoding them both.</p>
<h4 id="global-configuration">Global Configuration<a class="headerlink" href="#global-configuration" title="Permanent link">&para;</a></h4>
<p>It's possible to provision access to the libStorage API both globally and per
service. For example, the below configuration restricts all access to the
libStorage API to the bearer token from above:</p>
<pre><code class="yaml">libstorage:
  server:
    auth:
      key: MySuperSecretSigningKey
      alg: HS256
      allow:
      - akutz
</code></pre>

<p>The above configuration snippet defines a new property,
<code>libstorage.server.auth</code>. This property contains three child properties:
<code>key</code>, <code>alg</code>, <code>allow</code>, <code>deny</code>, and <code>disabled</code>.</p>
<p>The property <code>libstorage.server.auth.key</code> is the secret key used to verify
the signatures of the tokens included in API calls. If the property's value
is a valid file path then the contents of the file are used as the key. The
value of <code>libstorage.server.auth.alg</code> specifies the cryptographic algorithm
used to sign and verify the tokens. It has a default value of <code>HS256</code>. Valid
algorithms include:</p>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Strength</th>
<th>Config Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA</a></td>
<td>256</td>
<td><code>ES256</code></td>
</tr>
<tr>
<td></td>
<td>384</td>
<td><code>ES384</code></td>
</tr>
<tr>
<td></td>
<td>512</td>
<td><code>ES512</code></td>
</tr>
<tr>
<td><a href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC</a></td>
<td>256</td>
<td><code>HS256</code></td>
</tr>
<tr>
<td></td>
<td>384</td>
<td><code>HS384</code></td>
</tr>
<tr>
<td></td>
<td>512</td>
<td><code>HS512</code></td>
</tr>
<tr>
<td><a href="http://www.emc.com/emc-plus/rsa-labs/historical/raising-standard-rsa-signatures-rsa-pss.htm">RSA-PSS</a></td>
<td>256</td>
<td><code>PS256</code></td>
</tr>
<tr>
<td></td>
<td>384</td>
<td><code>PS384</code></td>
</tr>
<tr>
<td></td>
<td>512</td>
<td><code>PS512</code></td>
</tr>
<tr>
<td><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a></td>
<td>256</td>
<td><code>RS256</code></td>
</tr>
<tr>
<td></td>
<td>384</td>
<td><code>RS384</code></td>
</tr>
<tr>
<td></td>
<td>512</td>
<td><code>RS512</code></td>
</tr>
</tbody>
</table>
<p>Both the properties <code>libstorage.server.auth.allow</code> and
<code>libstorage.server.auth.deny</code> are arrays of strings. The values can be
either the subject of the token or the complete JWT. The <code>allow</code> property
indicates which tokens are valid and the <code>deny</code> property is a way to
explicitly revoke access.</p>
<div class="admonition note">
<p class="admonition-title">note</p>
<p>Please be aware that by virtue of defining the property
<code>libstorage.server.auth.allow</code>, access to the server is restricted to
requests with valid tokens only and anonymous access is no longer allowed.</p>
</div>
<p>There may be occasions when it is necessary to temporarily disable token-based
access restrictions. It's possible to do this without removing the token
configuration by setting the property <code>libstorage.server.auth.disabled</code>
to a boolean true value:</p>
<pre><code class="yaml">libstorage:
  server:
    auth:
      disabled: true
      key:      MySuperSecretSigningKey
      allow:
      - akutz
</code></pre>

<h4 id="service-configuration">Service Configuration<a class="headerlink" href="#service-configuration" title="Permanent link">&para;</a></h4>
<p>The previous section described how to restrict access at the global level.
This section reviews service-level token configurations.</p>
<pre><code class="yaml">libstorage:
  server:
    services:
      ebs-00:
        driver: ebs
        auth:
          key: MySuperSecretSigningKey
          allow:
          - akutz
      ebs-01:
        driver: ebs
</code></pre>

<p>The above configuration defines a token configuration for the service <code>ebs-00</code>
but <strong>not</strong> the service <code>ebs-01</code>. That means that API calls to the resource
<code>/volumes/ebs-00</code> require a valid token whereas API calls to the resource
<code>/volumes/ebs-01</code> do not.</p>
<div class="admonition note">
<p class="admonition-title">note</p>
<p>If an API call without a token is submitted that acts on multiple
resources and one or more of those resources is configured for token-based
access then the call  will result in an HTTP status of 401 <em>Unauthorized</em>.</p>
</div>
<h4 id="global-vs-service">Global vs. Service<a class="headerlink" href="#global-vs-service" title="Permanent link">&para;</a></h4>
<p>It is also possible to configure both global token-based access at the same
time as service token-based access. However, there are some important details
of which to be aware when doing so.</p>
<ol>
<li>
<p>When combining global and service token configurations, only the global
token key is respected. Otherwise tokens would always be invalid either at
the global or service scope since a token is signed by a single key.</p>
</li>
<li>
<p>The global <code>allow</code> list grants access globally but can be overridden by
including a token in a service's <code>deny</code> list.</p>
</li>
<li>
<p>The global <code>deny</code> list restricts access globally and cannot be overridden
by including a token in a service's <code>allow</code> list. For example, consider the
following configuration snippet:</p>
<pre><code>libstorage:
  server:
    auth:
      key:   MySuperSecretSigningKey
      allow:
      - akutz
      deny:
      - cduchesne
    services:
      ebs-00:
        driver: ebs
        auth:
          allow:
          - cduchesne
</code></pre>
<p>The above example defines a global deny list. That means that even though
the service <code>ebs-00</code> includes <code>cduchesne</code> in its own allow list, requests
to service <code>ebs-00</code> with <code>cduchesne</code>'s bearer token are denied because
that token is denied globally.</p>
</li>
</ol>
<h4 id="client-config">Client Config<a class="headerlink" href="#client-config" title="Permanent link">&para;</a></h4>
<p>Up until now the discussion surrounding security tokens has been centered on
server-side configuration. However, the libStorage client can also be
configured to send tokens as part of its standard API call workflow. For
example:</p>
<pre><code>libstorage:
  client:
    auth:
      token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MjI2ODg1NTAsImlhdCI6MTQ5MTIzODk1MCwibmJmIjoxNDkxMjM4OTUwLCJzdWIiOiJha3V0eiJ9.3eAA7AQZUGrwA42H64qKbu8QF_AHpSsJSMR0FALnKj8
</code></pre>

<p>The above client-side configuration snippet defines the property
<code>libstorage.client.auth.token</code>, the JWT used for outgoing HTTP calls as
the bearer token.</p>
<h3 id="embedded-configuration">Embedded Configuration<a class="headerlink" href="#embedded-configuration" title="Permanent link">&para;</a></h3>
<p>If <code>libStorage</code> is embedded into another application, such as
<a href="https://github.com/codedellemc/rexray"><code>REX-Ray</code></a>, then that application may
manage its own configuration and supply the embedded <code>libStorage</code> instance
directly with a configuration object. In this scenario, the <code>libStorage</code>
configuration files are ignored in deference to the embedding application.</p>
<h3 id="data-directories">Data Directories<a class="headerlink" href="#data-directories" title="Permanent link">&para;</a></h3>
<p>The first time <code>libStorage</code> is executed it will create several directories if
they do not already exist:</p>
<ul>
<li><code>/etc/libstorage</code></li>
<li><code>/var/log/libstorage</code></li>
<li><code>/var/run/libstorage</code></li>
<li><code>/var/lib/libstorage</code></li>
</ul>
<p>The above directories will contain configuration files, logs, PID files, and
mounted volumes. However, the location of these directories can also be
influenced with the environment variable <code>LIBSTORAGE_HOME</code>. All of the above
data directories will be placed in their same paths, but prefixed by the path
specified via <code>LIBSTORAGE_HOME</code>, if <code>LIBSTORAGE_HOME</code> is in fact specified.</p>
<h3 id="configuration-methods">Configuration Methods<a class="headerlink" href="#configuration-methods" title="Permanent link">&para;</a></h3>
<p>There are three ways to configure <code>libStorage</code>:</p>
<ul>
<li>Command line options</li>
<li>Environment variables</li>
<li>Configuration files</li>
</ul>
<p>The order of the items above is also the order of precedence when considering
options set in multiple locations that may override one another. Values set
via CLI flags have the highest order of precedence, followed by values set by
environment variables, followed, finally, by values set in configuration files.</p>
<h3 id="configuration-files">Configuration Files<a class="headerlink" href="#configuration-files" title="Permanent link">&para;</a></h3>
<p>There are two <code>libStorage</code> configuration files - global and user:</p>
<ul>
<li><code>/etc/libstorage/config.yml</code></li>
<li><code>$HOME/.libstorage/config.yml</code></li>
</ul>
<p>Please note that while the user configuration file is located inside the user's
home directory, this is the directory of the user that starts <code>libStorage</code>. And
if <code>libStorage</code> is being started as a service, then <code>sudo</code> is likely being used,
which means that <code>$HOME/.libstorage/config.yml</code> won't point to <em>your</em> home
directory, but rather <code>/root/.libstorage/config.yml</code>.</p>
<h3 id="configuration-properties">Configuration Properties<a class="headerlink" href="#configuration-properties" title="Permanent link">&para;</a></h3>
<p>The section <a href="#configuration-methods">Configuration Methods</a> mentions there are
three ways to configure libStorage: config files, environment variables, and the
command line. However, this section will illuminate the relationship between the
names of the configuration file properties, environment variables, and CLI
flags.</p>
<p>Below is a simple configuration file that tells the <code>libStorage</code> client where
the <code>libStorage</code> server is hosted:</p>
<pre><code class="yaml">libstorage:
  host: tcp://192.168.0.20:7979
</code></pre>

<p>The property <code>libstorage.host</code> is a string. This value can also be set via
environment variables or the command line, but to do so requires knowing the
names of the environment variables or CLI flags to use. Luckily those are very
easy to figure out just by knowing the property names.</p>
<p>All properties that might appear in the <code>libStorage</code> configuration file
fall under some type of heading. For example, take the default configuration
above.</p>
<p>The rule for environment variables is as follows:</p>
<ul>
<li>Each nested level becomes a part of the environment variable name followed
    by an underscore <code>_</code> except for the terminating part.</li>
<li>The entire environment variable name is uppercase.</li>
</ul>
<p>Nested properties follow these rules for CLI flags:</p>
<ul>
<li>The root level's first character is lower-cased with the rest of the root
    level's text left unaltered.</li>
<li>The remaining levels' first characters are all upper-cased with the the
    remaining text of that level left unaltered.</li>
<li>All levels are then concatenated together.</li>
</ul>
<p>The following example builds on the previous. In this case we have added logging
directives to the client instance and reference how their transformation in
the table below the example.</p>
<pre><code class="yaml">  libstorage:
    host: tcp://192.168.0.20:7979
    logging:
      level: warn
      stdout:
      stderr:
      httpRequests: false
      httpResponses: false
</code></pre>

<p>The following table illustrates the transformations:</p>
<table>
<thead>
<tr>
<th>Property Name</th>
<th>Environment Variable</th>
<th>CLI Flag</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>libstorage.host</code></td>
<td><code>LIBSTORAGE_HOST</code></td>
<td><code>--libstorageHost</code></td>
</tr>
<tr>
<td><code>libstorage.logging.level</code></td>
<td><code>LIBSTORAGE_LOGGING_LEVEL</code></td>
<td><code>--libstorageLoggingLevel</code></td>
</tr>
<tr>
<td><code>libstorage.logging.stdout</code></td>
<td><code>LIBSTORAGE_LOGGING_STDOUT</code></td>
<td><code>--libstorageLoggingStdout</code></td>
</tr>
<tr>
<td><code>libstorage.logging.stderr</code></td>
<td><code>LIBSTORAGE_LOGGING_STDERR</code></td>
<td><code>--libstorageLoggingStderr</code></td>
</tr>
<tr>
<td><code>libstorage.logging.httpRequests</code></td>
<td><code>LIBSTORAGE_LOGGING_HTTPREQUESTS</code></td>
<td><code>--libstorageLoggingHttpRequests</code></td>
</tr>
<tr>
<td><code>libstorage.logging.httpResponses</code></td>
<td><code>LIBSTORAGE_LOGGING_HTTPRESPONSES</code></td>
<td><code>--libstorageLoggingHttpResponses</code></td>
</tr>
</tbody>
</table>
<h3 id="inherited-properties">Inherited Properties<a class="headerlink" href="#inherited-properties" title="Permanent link">&para;</a></h3>
<p>Referring to the section on defining
<a href="./#multiple-services">Multiple Services</a>, there is also another way
to define the TLS settings for the external TCP endpoint. The same configuration
can be rewritten and simplified in the process:</p>
<pre><code class="yaml">libstorage:
  integration:
    volume:
      operations:
        create:
          default:
            size: 1 # GB
  server:
    virtualbox:
      endpoint:       http://10.0.2.2:18083
      tls:            false
      controllerName: SATA
    services:
      virtualbox-00:
        driver: virtualbox
        virtualbox:
          volumePath: $HOME/VirtualBox/Volumes-00
      virtualbox-01:
        driver: virtualbox
        virtualbox:
          volumePath: $HOME/VirtualBox/Volumes-01
</code></pre>

<p>The above example may look different than the previous one, but it's actually
the same with a minor tweak in order to simplify configuration.</p>
<p>While there are still two VirtualBox services defined, <code>virtualbox-00</code> and
<code>virtualbox-01</code>, neither service contains configuration information about the
VirtualBox driver other than the <code>volumePath</code> property. This is because the
change affected above is to take advantage of inherited properties.</p>
<p>When a property is omitted, <code>libStorage</code> traverses the configuration instance
upwards, checking certain, predefined levels known as "scopes" to see if the
property value exists there. All configured services represent a valid
configuration scope as does <code>libstorage.server</code>.</p>
<p>Thus when the VirtualBox driver is initialized and it checks for its properties,
while the driver may only find the <code>volumePath</code> property defined under the
configured service scope, the property access attempt travels up the
configuration stack until it hits the <code>libstorage.server</code> scope where the
remainder of the VirtualBox driver's properties <em>are</em> defined.</p>
<h4 id="overriding-inherited-properties">Overriding Inherited Properties<a class="headerlink" href="#overriding-inherited-properties" title="Permanent link">&para;</a></h4>
<p>It's also possible to override inherited properties as is demonstrated in the
<a href="#logging">Logging configuration example</a> above:</p>
<pre><code class="yaml">libstorage:
  logging:
    level: warn
  integration:
    volume:
      operations:
        create:
          default:
            size: 1 # GB
  server:
    logging:
      level: info
    services:
      virtualbox:
        driver: virtualbox
        virtualbox:
          endpoint:       http://10.0.2.2:18083
          tls:            false
          volumePath:     $HOME/VirtualBox/Volumes
          controllerName: SATA
</code></pre>

<p>Note that while the log level is defined at the root of the config, it's also
defined at <code>libstorage.server.logging.level</code>. The latter value of <code>info</code>
overrides the former value of <code>warn</code>. Also please remember that even had the
latter, server-specific value of <code>info</code> not been defined, an attempt by to
access the log level by the server would be perfectly valid since the attempt
would traverse up the configuration data until it found the log level defined
at the root of the configuration.</p>
<h3 id="logging-configuration">Logging Configuration<a class="headerlink" href="#logging-configuration" title="Permanent link">&para;</a></h3>
<p>The <code>libStorage</code> log level determines the level of verbosity emitted by the
internal logger. The default level is <code>warn</code>, but there are three other levels
as well:</p>
<table>
<thead>
<tr>
<th>Log Level</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>error</code></td>
<td>Log only errors</td>
</tr>
<tr>
<td><code>warn</code></td>
<td>Log errors and anything out of place</td>
</tr>
<tr>
<td><code>info</code></td>
<td>Log errors, warnings, and workflow messages</td>
</tr>
<tr>
<td><code>debug</code></td>
<td>Log everything</td>
</tr>
</tbody>
</table>
<h3 id="tasks-configuration">Tasks Configuration<a class="headerlink" href="#tasks-configuration" title="Permanent link">&para;</a></h3>
<p>All operations received by the libStorage API are immediately enqueued into a
Task Service in order to divorce the business objective from the scope of the
HTTP request that delivered it. If a task completes before the HTTP request
times out, the result of the task is written to the HTTP response and sent to
the client. However, if the operation is long-lived and continues to execute
after the original HTTP request has timed out, the goroutine running the
operation will finish regardless.</p>
<p>In the case of such a timeout event, the client receives an HTTP status 408 -
Request Timeout. The HTTP response body also includes the task ID which can
be used to monitor the state of the remote call. The following resource URI can
be used to retrieve information about a task:</p>
<pre><code>GET /tasks/${taskID}
</code></pre>

<p>For systems that experience heavy loads the task system can also be a source of
potential resource issues. Because tasks are kept indefinitely at this point in
time, too many tasks over a long period of time can result in a massive memory
consumption, with reports of up to 50GB and more.</p>
<p>That's why the configuration property <code>libstorage.server.tasks.logTimeout</code> is
available to adjust how long a task is logged before it is removed from memory.
The default value is <code>0</code> -- that is, do not log the task in memory at all.</p>
<p>While this is in contradiction to the task retrieval example above --
obviously a task cannot be retrieved if it is not retained -- testing and
benchmarks have shown it is too dangerous to enable task retention by default.
Instead tasks are removed immediately upon completion.</p>
<p>The follow configuration example illustrates a libStorage server that keeps
tasks logged for 10 minutes before purging them from memory:</p>
<pre><code class="yaml">libstorage:
  server:
    tasks:
      logTimeout: 10m
</code></pre>

<p>The <code>libstorage.server.tasks.logTimeout</code> property can be set to any value that
is parseable by the Golang
<a href="https://golang.org/pkg/time/#ParseDuration">time.ParseDuration</a> function. For
example, <code>1000ms</code>, <code>10s</code>, <code>5m</code>, and <code>1h</code> are all valid values.</p>
<h3 id="driver-configuration">Driver Configuration<a class="headerlink" href="#driver-configuration" title="Permanent link">&para;</a></h3>
<p>There are three types of drivers:</p>
<ol>
<li>OS Drivers</li>
<li>Storage Drivers</li>
<li>Integration Drivers</li>
</ol>
<h4 id="os-drivers">OS Drivers<a class="headerlink" href="#os-drivers" title="Permanent link">&para;</a></h4>
<p>Operating system (OS) drivers enable <code>libStorage</code> to manage storage on
the underlying OS. Currently the following OS drivers are supported:</p>
<table>
<thead>
<tr>
<th>Driver</th>
<th>Driver Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linux</td>
<td>linux</td>
</tr>
</tbody>
</table>
<p>The OS driver <code>linux</code> is automatically activated when <code>libStorage</code> is running on
the Linux OS.</p>
<h4 id="storage-drivers">Storage Drivers<a class="headerlink" href="#storage-drivers" title="Permanent link">&para;</a></h4>
<p>Storage drivers enable <code>libStorage</code> to communicate with direct-attached or
remote storage systems. Currently the following storage drivers are supported:</p>
<table>
<thead>
<tr>
<th>Driver</th>
<th>Driver Name</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../storage-providers/#dell-emc-isilon">Dell EMC Isilon</a></td>
<td>isilon</td>
</tr>
<tr>
<td><a href="../storage-providers/#dell-emc-scaleio">Dell EMC ScaleIO</a></td>
<td>scaleio</td>
</tr>
<tr>
<td><a href="../storage-providers/#virtualbox">VirtualBox</a></td>
<td>virtualbox</td>
</tr>
<tr>
<td><a href="../storage-providers/#aws-ebs">AWS EBS</a></td>
<td>ebs, ec2</td>
</tr>
<tr>
<td><a href="../storage-providers/#aws-efs">AWS EFS</a></td>
<td>efs</td>
</tr>
<tr>
<td><a href="../storage-providers/#aws-s3fs">AWS S3FS</a></td>
<td>s3fs</td>
</tr>
<tr>
<td><a href="../storage-providers/#ceph-rbd">Ceph RBD</a></td>
<td>rbd</td>
</tr>
<tr>
<td><a href="../storage-providers/#gce-persistent-disk">GCE PD</a></td>
<td>gcepd</td>
</tr>
<tr>
<td><a href="../storage-providers/#azure-ud">Azure UD</a></td>
<td>azureud</td>
</tr>
</tbody>
</table>
<p>The <code>libstorage.server.libstorage.storage.driver</code> property can be used to
activate a storage drivers. That is not a typo; the <code>libstorage</code> key is repeated
beneath <code>libstorage.server</code>. This is because configuration property paths are
absolute, and when nested under an architectural component, such as
<code>libstorage.server</code>, the entire key path must be replicated.</p>
<p>That said, and this may seem to contradict the last point, the storage driver
property is valid <em>only</em> on the server. Well, not really. Internally the
<code>libStorage</code> client uses the same configuration property to denote its own
storage driver. This internal storage driver is actually how the <code>libStorage</code>
client communicates with the <code>libStorage</code> server.</p>
<h4 id="integration-drivers">Integration Drivers<a class="headerlink" href="#integration-drivers" title="Permanent link">&para;</a></h4>
<p>Integration drivers enable <code>libStorage</code> to integrate with schedulers and other
storage consumers, such as <code>Docker</code> or <code>Mesos</code>. Currently the following
integration drivers are supported:</p>
<table>
<thead>
<tr>
<th>Driver</th>
<th>Driver Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linux</td>
<td>linux</td>
</tr>
</tbody>
</table>
<p>The integration driver <code>linux</code> provides necessary functionality to enable
most consuming platforms to work with storage volumes.</p>
<h3 id="volume-configuration">Volume Configuration<a class="headerlink" href="#volume-configuration" title="Permanent link">&para;</a></h3>
<p>This section describes various global configuration options related to an
integration driver's volume operations, such as mounting and unmounting volumes.</p>
<h4 id="volume-properties">Volume Properties<a class="headerlink" href="#volume-properties" title="Permanent link">&para;</a></h4>
<p>The properties listed below are the global properties valid for an integration
driver's volume-related properties.</p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>libstorage.integration.volume.operations.mount.preempt</code></td>
<td>Forcefully take control of volumes when requested</td>
</tr>
<tr>
<td><code>libstorage.integration.volume.operations.mount.path</code></td>
<td>The default host path for mounting volumes</td>
</tr>
<tr>
<td><code>libstorage.integration.volume.operations.mount.rootPath</code></td>
<td>The path within the volume to return to the integrator (ex. <code>/data</code>)</td>
</tr>
<tr>
<td><code>libstorage.integration.volume.operations.create.disable</code></td>
<td>Disable the ability for a volume to be created</td>
</tr>
<tr>
<td><code>libstorage.integration.volume.operations.remove.disable</code></td>
<td>Disable the ability for a volume to be removed</td>
</tr>
</tbody>
</table>
<p>The properties in the next table are the configurable parameters that affect
the default values for volume creation requests.</p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>libstorage.integration.volume.operations.create.default.size</code></td>
<td>Size in GB</td>
</tr>
<tr>
<td><code>libstorage.integration.volume.operations.create.default.iops</code></td>
<td>IOPS</td>
</tr>
<tr>
<td><code>libstorage.integration.volume.operations.create.default.type</code></td>
<td>Type of Volume or Storage Pool</td>
</tr>
<tr>
<td><code>libstorage.integration.volume.operations.create.default.fsType</code></td>
<td>Type of filesystem for new volumes (ext4/xfs)</td>
</tr>
<tr>
<td><code>libstorage.integration.volume.operations.create.default.availabilityZone</code></td>
<td>Extensible parameter per storage driver</td>
</tr>
</tbody>
</table>
<h4 id="disable-create">Disable Create<a class="headerlink" href="#disable-create" title="Permanent link">&para;</a></h4>
<p>The disable create feature enables you to disallow any volume creation activity.
Any requests will be returned in a successful manner, but the create will not
get passed to the backend storage platform.</p>
<pre><code class="yaml">libstorage:
  integration:
    volume:
      operations:
        create:
          disable: true
</code></pre>

<h4 id="disable-remove">Disable Remove<a class="headerlink" href="#disable-remove" title="Permanent link">&para;</a></h4>
<p>The disable remove feature enables you to disallow any volume removal activity.
Any requests will be returned in a successful manner, but the remove will not
get passed to the backend storage platform.</p>
<pre><code class="yaml">libstorage:
  integration:
    volume:
      operations:
        remove:
          disable: true
</code></pre>

<h4 id="preemption">Preemption<a class="headerlink" href="#preemption" title="Permanent link">&para;</a></h4>
<p>There is a capability to preemptively detach any existing attachments to other
instances before attempting a mount.  This will enable use cases for
availability where another instance must be able to take control of a volume
without the current owner instance being involved.  The operation is considered
equivalent to a power off of the existing instance for the device.</p>
<p>Example configuration file follows:</p>
<pre><code class="yaml">libstorage:
  integration:
    volume:
      operations:
        mount:
          preempt: true
</code></pre>

<table>
<thead>
<tr>
<th>Driver</th>
<th>Supported</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dell EMC Isilon</td>
<td>Not yet</td>
</tr>
<tr>
<td>Dell EMC ScaleIO</td>
<td>Yes</td>
</tr>
<tr>
<td>VirtualBox</td>
<td>Yes</td>
</tr>
<tr>
<td>AWS EBS</td>
<td>Yes</td>
</tr>
<tr>
<td>AWS EFS</td>
<td>No</td>
</tr>
<tr>
<td>AWS S3FS</td>
<td>No</td>
</tr>
<tr>
<td>Ceph RBD</td>
<td>No</td>
</tr>
<tr>
<td>GCE PD</td>
<td>Yes</td>
</tr>
<tr>
<td>Azure UD</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<h4 id="ignore-used-count">Ignore Used Count<a class="headerlink" href="#ignore-used-count" title="Permanent link">&para;</a></h4>
<p>By default accounting takes place during operations that are performed
on <code>Mount</code>, <code>Unmount</code>, and other operations.  This only has impact when running
as a service through the HTTP/JSON interface since the counts are persisted
in memory.  The purpose of respecting the <code>Used Count</code> is to ensure that a
volume is not unmounted until the unmount requests have equaled the mount
requests.  </p>
<p>In the <code>Docker</code> use case if there are multiple containers sharing a volume
on the same host, the the volume will not be unmounted until the last container
is stopped.  </p>
<p>The following setting should only be used if you wish to <em>disable</em> this
functionality.  This would make sense if the accounting is being done from
higher layers and all unmount operations should proceed without control.</p>
<pre><code class="yaml">libstorage:
  integration:
    volume:
      operations:
        unmount:
          ignoreUsedCount: true
</code></pre>

<p>Currently a reset of the service will cause the counts to be reset.  This
will cause issues if <em>multiple containers</em> are sharing a volume.  If you are
sharing volumes, it is recommended that you reset the service along with the
accompanying container runtime (if this setting is false) to ensure they are
synchronized.  </p>
<h4 id="volume-path-cache">Volume Path Cache<a class="headerlink" href="#volume-path-cache" title="Permanent link">&para;</a></h4>
<p>In order to optimize <code>Path</code> requests, the paths of actively mounted volumes
returned as the result of a <code>List</code> request are cached. Subsequent <code>Path</code>
requests for unmounted volumes will not dirty the cache. Only once a volume
has been mounted will the cache be marked dirty and the volume's path retrieved
and cached once more.</p>
<p>The following configuration example illustrates the two path cache properties:</p>
<pre><code class="yaml">libstorage:
  integration:
    volume:
      operations:
        path:
          cache:
            enabled: true
            async:   true
</code></pre>

<p>Volume path caching is enabled and asynchronous by default, so it's possible to
entirely omit the above configuration excerpt from a production deployment, and
the system will still use asynchronous caching. Setting the <code>async</code> property to
<code>false</code> simply means that the initial population of the cache will be handled
synchronously, slowing down the program's startup time.</p>
<h4 id="volume-root-path">Volume Root Path<a class="headerlink" href="#volume-root-path" title="Permanent link">&para;</a></h4>
<p>When volumes are mounted there can be an additional path that is specified to
be created and passed as the valid mount point.  This is required for certain
applications that do not want to place data from the root of a mount point.</p>
<p>The default is the <code>/data</code> path.  If a value is set by
<code>linux.integration.volume.operations.mount.rootPath</code>, then the default will be
overwritten.</p>
<pre><code class="yaml">libstorage:
  integration:
    volume:
      operations:
        mount:
          rootPath: /data
</code></pre>

<h3 id="rest-configuration">REST Configuration<a class="headerlink" href="#rest-configuration" title="Permanent link">&para;</a></h3>
<p>This section reviews advanced HTTP REST configuration options:</p>
<h4 id="parse-post-options">Parse POST Options<a class="headerlink" href="#parse-post-options" title="Permanent link">&para;</a></h4>
<p>Normally an incoming POST request with an <code>opts</code> field does not copy the
key/value pairs in the <code>opts</code> map into the fields that match the request's
schema. For example, take a look at the following request:</p>
<pre><code class="json">{
    &quot;name&quot;: &quot;newVolume&quot;,
    &quot;iops&quot;: 0,
    &quot;size&quot;: 5,
    &quot;type&quot;: &quot;block&quot;,
    &quot;opts&quot;: {
        &quot;encrypted&quot;: true,
    }
}
</code></pre>

<p>The above request is used for creating a new volume, and it appears that the
intention is to create the volume as encrypted. However, the <code>encrypted</code> field
is part of the free-form <code>opts</code> piece of the request. The <code>opts</code> map is for
data that is not yet part of the official libStorage API and schema. Certain
drivers may parse data out of the <code>opts</code> field, but it <em>is</em> driver specific.
The libStorage server does not normally attempt to parse this field's keys
and match it to the request's fields. A proper request would look like this:</p>
<pre><code class="json">{
    &quot;name&quot;:      &quot;newVolume&quot;,
    &quot;iops&quot;:      0,
    &quot;size&quot;:      5,
    &quot;type&quot;:      &quot;block&quot;,
    &quot;encrypted&quot;: true,
}
</code></pre>

<p>In order to make things a little easier on clients, a server can be configured
to treat the first JSON request as equal to the second. This feature is disabled
by default due to the possibility of side-effects. For example, a value in the
<code>opts</code> map could unintentionally overwrite the intended value if both keys are
the same.</p>
<p>To enable this feature, the libStorage server's configuration should set the
<code>libstorage.server.parseRequestOpts</code> property to true. An example YAML snippet
with this property enabled resembles the following:</p>
<pre><code class="yaml">libstorage:
  server:
    parseRequestOpts: true
</code></pre>

<p>With the above property set to <code>true</code>, values in a request's <code>opts</code> map will be
copied to the corresponding key in the request proper.</p></div>
        </div>
        

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <!--
        <script src="../../.themes/yeti/js/base.js"></script>
        <script src="../../.themes/yeti/js/bootstrap-3.0.3.min.js"></script>
        <script src="../../.themes/yeti/js/highlight.pack.js"></script>
        <script src="../../.themes/yeti/js/jquery-1.10.2.min.js"></script>
        -->

    </body>

</html>